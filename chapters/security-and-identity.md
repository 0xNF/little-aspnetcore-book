# Security and identity
Security is a major concern of any modern web application or API. 

ASP.NET Core helps you build security into your app from the beginning. The MVC + Individual Authentication template you used to scaffold the project includes a number of classes built on top of ASP.NET Core Identity, an authentication and identity system that's part of ASP.NET Core.
## What is ASP.NET Core Identity?
ASP.NET Core Identity is the identity system that ships with ASP.NET Core. Like everything else in the ASP.NET Core ecosystem, it's a set of NuGet packages that can be installed in any project (and are already included if you use the default template, or reference the `Microsoft.AspNetCore.All` metapackage).

ASP.NET Core Identity takes care of storing user accounts, hashing and storing passwords, and managing roles for users. It supports email/password login, multi-factor authentication, social login with providers like Google and Facebook, as well as connecting to other services using protocols like OAuth 2.0 and OpenID Connect.

The Register and Login views that ship with the MVC + Individual Auth template already take advantage of ASP.NET Core Identity, and they already work! Try registering for an account and logging in.
## Add Facebook login
Out of the box, the Individual Auth template includes functionality for registering using an email and password. You can extend this by plugging in additional identity providers like Google and Facebook.

For any external provider, you need to do two things:

1. Create an app (sometimes called a *client*) on the external provider that represents your application
1. Copy the ID and secret generated by the provider and put them in your code

### Create an app in Facebook

You can create new Facebook apps using the Facebook Developer console at https://developers.facebook.com/apps. Click **Add a New App** and follow the instructions to create an app ID.

> Sidebar: If you don't have a Facebook account, you can set up Google or Twitter login instead. The steps on the provider's site will be different, but the code is almost identical.

Next, set up Facebook Login and then click Settings on the left side:

!img: facebook-login-settings.png

Add the following URL to the **Valid OAuth redirect URIs** box:

```
http://localhost:5000/signin-facebook
```

Click **Save Changes** and then head over to the Dashboard page. Here you can see the app ID and secret generated by Facebook, which you'll need in a moment (keep this tab open).

To enable Facebook login in ASP.NET Core Identity, add this code anywhere in the `ConfigureServices` method in the `Startup` class:

```csharp
services
    .AddAuthentication()
    .AddFacebook(options =>
    {
        options.AppId = Configuration["Facebook:AppId"];
        options.AppSecret = Configuration["Facebook:AppSecret"];
    });
```

Instead of hardcoding the Facebook app ID and secret in your code, the values are pulled from the configuration system. The `appsettings.json` file is the main place to store configuration data for your project. However, since it's checked into source control, it's not good for sensitive data like an app secret. (If your app secret was pushed to GitHub, for example, anyone could steal it and do bad things on your behalf.)

### Store secrets safely with the Secrets Manager

You can use the Secrets Manager tool for sensitive data like an app secret. Run this line in the terminal to make sure it's installed (make sure you're currently in the project directory):

```bash
dotnet user-secrets --help
```

> Sidebar: If you open up the `AspNetCoreTodo.csproj` file, you'll see the line that installs the tool in your project:

> ```xml
<DotNetCliToolReference Include="Microsoft.Extensions.SecretManager.Tools" Version="2.0.0" />
```

Copy the app ID and secret from the Facebook app dashboard and use the `set` command to save the values in the Secrets Manager:

```bash
dotnet user-secrets set Facebook:AppId <paste app id>
dotnet user-secrets set Facebook:AppSecret <paste app secret>
```

The values from the Secrets Manager are loaded into the `Configuration` property when your application starts up, so they're available to the code in `ConfigureServices` you added before.

Run your application and click the Login link in the navbar. You'll see a new button for logging in with Facebook:

!img: facebook-login-button.png

Try logging in with Facebook. You'll be redirected and prompted to give your app permission in Facebook, then redirected back and logged in.
## Require authentication
Often you'll want to require the user to log in before they can access certain parts of your application (but not others). For example, it makes sense to show the home page to everyone, but only show your to-do list after you've logged in.

You can use the `[Authorize]` attribute in ASP.NET Core to require a logged-in user for a particular action, or an entire controller. To require authentication for all actions of the `TodoController`, add the attribute above the first line of the controller:

```csharp
[Authorize]
public class TodoController : Controller
{
  // …
}
```

Add this `using` statement at the top of the file:

```csharp
using Microsoft.AspNetCore.Authorization;
```

> Sidebar: Strictly speaking, **authentication** deals with whether you are logged in at all, while **authorization** deals with whether you have permission to access a specific area. Despite the name of the attribute, we are really doing an authentication check here.

Try running the application and accessing `/todo` without being logged in. You'll be redirected to the login page automatically.
## Using identity in the application
The items in the to-do list are still visible to all users, because the to-do entities themselves aren't tied to a particular user. Now that the `[Authorize]` attribute ensures that you must be logged in to see the to-do view, you can filter the database query based on who is logged in.

### Only show the current user's to-do items

First, inject a `UserManager<ApplicationUser>` into the `TodoController`:

**Controllers/TodoController.cs**

```csharp
[Authorize]
public class TodoController : Controller
{
    private readonly ITodoItemService _todoItemService;
    private readonly UserManager<ApplicationUser> _userManager;

    public TodoController(
        ITodoItemService todoItemService,
        UserManager<ApplicationUser> userManager)
    {
        _todoItemService = todoItemService;
        _userManager = userManager;
    }

    // …
}
```

You'll need to add a new `using` statement at the top:

```csharp
using Microsoft.AspNetCore.Identity;
```

The `UserManager` class is part of ASP.NET Core Identity. You can use it to look up the current user in the `Index` action:

```csharp
public async Task<IActionResult> Index()
{
    var currentUser = await _userManager.GetUserAsync(User);
    if (currentUser == null) return Challenge();

    var todoItems = await _todoItemService.GetIncompleteItemsAsync(currentUser);

    var model = new TodoViewModel()
    {
        Items = todoItems
    };

    return View(model);
}
```

The new code at the top of the action method uses the `UserManager` to get the current user from the special `User` property available in the action:

```csharp
var currentUser = await _userManager.GetUserAsync(User);
```

> Sidebar: If there is a logged-in user, the `User` property contains a lightweight object with some of the user's information. The `UserManager` uses this to look up the full user details in the database.

The value of `currentUser` should never be null, because the `[Authorize]` attribute is present on the controller. However, it's a good idea to do a sanity check, just in case. You can use the `Challenge()` method to force the user to log in again if their information is missing:

```csharp
if (currentUser == null) return Challenge();
```

Since you're now passing an `ApplicationUser` parameter to `GetIncompleteItemsAsync`, you'll need to update the `ITodoItemService` interface:

```csharp
Task<TodoItem[]> GetIncompleteItemsAsync(ApplicationUser user);
```

The next step is to update the database query and show only items owned by the current user. First, you'll need to add a new property to the `TodoItem` entity model so each item can know who owns it:

```csharp
public ApplicationUser Owner { get; set; }
```

Now you can update the `GetIncompleteItemsAsync` method in `EfCoreTodoItemService` and add another clause to the `Where` statement:

```csharp
public Task<TodoItem[]> GetIncompleteItemsAsync(ApplicationUser user)
{
    return _context.Items
        .Where(x => x.IsDone == false && x.Owner.Id == user.Id)
        .ToArrayAsync();
}
```

If you run the application and register or log in, you'll see an empty to-do list. Unfortunately, you can't add items to it, because the `Owner` property of new items isn't being set.

### Update the Add and Mark Done flows

You'll need to use the `UserManager` to get the current user in the `AddItem` and `MarkDone` action methods, just like you did in `Index`. The only difference is that these methods will return a `401 Unauthorized` response to the frontend code, instead of challenging and redirecting the user to the login page.

Here are both updated methods in `TodoController`:

```csharp
public async Task<IActionResult> AddItem(NewTodoItem newItem)
{
    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }

    var currentUser = await _userManager.GetUserAsync(User);
    if (currentUser == null) return Unauthorized();

    var successful = await _todoItemService.AddItem(newItem, currentUser);
    if (!successful)
    {
        return BadRequest(new { error = "Could not add item." });
    }

    return Ok();
}

public async Task<IActionResult> MarkDone(Guid id)
{
    if (id == Guid.Empty) return BadRequest();

    var currentUser = await _userManager.GetUserAsync(User);
    if (currentUser == null) return Unauthorized();

    var successful = await _todoItemService.MarkDone(id, currentUser);
    if (!successful) return BadRequest();

    return Ok();
}
```

Both service methods must now accept an `ApplicationUser` parameter. Update the interface definition in `ITodoItemService`:

```csharp
Task<bool> AddItem(NewTodoItem newItem, ApplicationUser user);

Task<bool> MarkDone(Guid id, ApplicationUser user);
```

And finally, update the service method implementations in `EfCoreTodoItemService`. For the Add Item flow, set the `Owner` property when you construct a `new TodoItem`:

```csharp
public async Task<bool> AddItem(NewTodoItem newItem, ApplicationUser user)
{
    var entity = new TodoItem
    {
        Id = Guid.NewGuid(),
        Owner = user,
        IsDone = false,
        Title = newItem.Title,
        DueAt = DateTimeOffset.Now.AddDays(3)
    };

    // ...
}
```

The `Where` clause in the `MarkDone` method needs the same update as the `GetIncompleteItemsAsync` method:

```csharp
public async Task<bool> MarkDone(Guid id, ApplicationUser user)
{
    var item = await _context.Items
        .Where(x => x.Id == id && x.Owner.Id == user.Id)
        .SingleOrDefaultAsync();

    // ...
```

All done! Try using the application with two different user accounts. The to-do items stay private for each account.
## Role-based authorization
Roles are a common approach to authorization in web application. For example, you might have an Administrator role that allows administrators to see and manage all the users registered for your app, while normal users can only see their own information.

> Sidebar: Authorization is asking the question: "Do I have permission to do this?" It's distinct from authentication, which deals with whether the user is known (registered) or anonymous (a visitor without an account).

When you wrote code to seed the database back in chapter 5, you created an administrator role and an admin account with that role. With that in place, you can create a new section of the site for administrators, and a policy that restricts it based on the current user's role.

### Add a Manage Users page

First, create a new controller:

**Controllers/ManageUsersController.cs**

```csharp
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using AspNetCoreTodo.Models;
using Microsoft.EntityFrameworkCore;

namespace AspNetCoreTodo.Controllers
{
    [Authorize(Roles = Constants.AdministratorRole)]
    public class ManageUsersController : Controller
    {
        private readonly UserManager<ApplicationUser> _userManager;
        
        public ManageUsersController(UserManager<ApplicationUser> userManager)
        {
            _userManager = userManager;
        }

        public async Task<IActionResult> Index()
        {
            var admins = await _userManager
                .GetUsersInRoleAsync(Constants.AdministratorRole);

            var everyone = await _userManager.Users
                .ToArrayAsync();

            var model = new ManageUsersViewModel
            {
                Administrators = admins,
                Everyone = everyone
            };

            return View(model);
        }
    }
}
```

Setting the `Roles` property on the `[Authorize]` attribute will ensure that the user must be logged in **and** have the Administrator role in order to view the page.

Next, create a view model:

**Models/ManageUsersViewModel.cs**

```csharp
using System.Collections.Generic;
using AspNetCoreTodo.Models;

namespace AspNetCoreTodo
{
    public class ManageUsersViewModel
    {
        public IEnumerable<ApplicationUser> Administrators { get; set; }

        public IEnumerable<ApplicationUser> Everyone { get; set; }
    }
}
```

Finally, create a view for the Index action:

**Views/ManageUsers/Index.cshtml**

```razor
@model ManageUsersViewModel

@{
    ViewData["Title"] = "Manage users";
}

<h2>@ViewData["Title"]</h2>

<h3>Administrators</h3>

<table class="table">
    <thead>
        <tr>
            <td>Id</td>
            <td>Email</td>
        </tr>
    </thead>
    
    @foreach (var user in Model.Administrators)
    {
        <tr>
            <td>@user.Id</td>
            <td>@user.Email</td>
        </tr>
    }
</table>

<h3>Everyone</h3>

<table class="table">
    <thead>
        <tr>
            <td>Id</td>
            <td>Email</td>
        </tr>
    </thead>
    
    @foreach (var user in Model.Everyone)
    {
        <tr>
            <td>@user.Id</td>
            <td>@user.Email</td>
        </tr>
    }
</table>
```

Start up the application and try to access the `/ManageUsers` route as a normal user. You'll see this access denied page:

!TODO: screenshot

Then, log in with the administrator account. You'll see the list of users registered for the app.

> Sidebar: Try adding more administration features to this page. For example, you could add a button that gives an administrator the ability to disable a user account.

### Check for authorization in a view

The `[Authorize]` attribute makes it easy to perform an authorization check in a controller or action method, but what if you need to check authorization in a view? For example, it would be nice to display a Manage Users link in the navbar if the logged-in user is an Administrator.

You can inject the `UserManager` directly into a view to do these authorization checks. To keep your views clean and organized, create a new partial view that will add an item to the navbar in the layout:

**Views/Shared/_AdminActionsPartial.cshtml**

```razor
@using Microsoft.AspNetCore.Identity
@using AspNetCoreTodo.Models

@inject SignInManager<ApplicationUser> SignInManager
@inject UserManager<ApplicationUser> UserManager

@if (SignInManager.IsSignedIn(User))
{
    var currentUser = await UserManager.GetUserAsync(User);

    var isAdmin = currentUser != null
        && await UserManager.IsInRoleAsync(currentUser, Constants.AdministratorRole);

    if (isAdmin) {
        <ul class="nav navbar-nav navbar-right">
            <li><a asp-controller="ManageUsers" asp-action="Index">Manage Users</a></li>
        </ul>
    }
}
```

This partial first uses the `SignInManager` to quickly determine whether the user is logged in. If they aren't, the code can end early. If there is a logged-in user, the `UserManager` is used to look up their details and perform an authorization check with `IsInRoleAsync`. If all checks succeed, a navbar item is rendered.

To include this partial in the main layout, edit `Views/Shared_Layout.cshtml` and add it in the navbar section:

```razor
<div class="navbar-collapse collapse">
    <ul class="nav navbar-nav">
        <li><a asp-area="" asp-controller="Home" asp-action="Index">Home</a></li>
        <li><a asp-area="" asp-controller="Home" asp-action="About">About</a></li>
        <li><a asp-area="" asp-controller="Home" asp-action="Contact">Contact</a></li>
    </ul>
    @await Html.PartialAsync("_LoginPartial")
    @await Html.PartialAsync("_AdminActionsPartial")
</div>
```

When you log in with an administrator account, you'll now see a new item on the top right:

!TODO: screenshot
## Wrap up
ASP.NET Core Identity is a powerful security and identity system that helps you add authentication and authorization checks, and makes it easy to integrate with external identity providers. The `dotnet new` templates give you pre-built views and controllers that handle common scenarios like login and registration so you can get up and running quickly.

There's much more that ASP.NET Core Identity can do. You can learn more in the documentation and examples available at https://docs.asp.net.
